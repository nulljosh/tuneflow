#!/bin/bash

# Auto Git Push System
# Automatically detects significant code changes and pushes to GitHub
# Watches for >10 line changes or new files

set -e

COMMAND="${1:-.}"
WATCH_DIR="${2:-.}"
MIN_LINES=10
DEBOUNCE_SECONDS=5
TEMP_STASH=".agp-stash"
LOG_FILE="${WATCH_DIR}/.agp.log"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

error() {
    echo -e "${RED}[ERROR]${NC} $*" | tee -a "$LOG_FILE" >&2
}

success() {
    echo -e "${GREEN}[OK]${NC} $*" | tee -a "$LOG_FILE"
}

info() {
    echo -e "${BLUE}[INFO]${NC} $*" | tee -a "$LOG_FILE"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" | tee -a "$LOG_FILE"
}

# Check if directory is a git repo
check_git_repo() {
    if ! git -C "$WATCH_DIR" rev-parse --git-dir > /dev/null 2>&1; then
        error "$WATCH_DIR is not a git repository"
        return 1
    fi
}

# Get files changed since last commit
get_changed_files() {
    cd "$WATCH_DIR"
    
    # Get all unstaged and untracked files
    (git diff --name-only 2>/dev/null || true; \
     git diff --cached --name-only 2>/dev/null || true; \
     git ls-files --others --exclude-standard 2>/dev/null || true) | \
    sort | uniq
}

# Count lines changed in a file
count_changes() {
    local file="$1"
    cd "$WATCH_DIR"
    
    if [ ! -f "$file" ]; then
        # New or deleted file
        echo "999"  # Treat as significant change
        return
    fi
    
    # Count insertions from git diff
    git diff "$file" 2>/dev/null | grep -c "^+" | grep -v "^+++$" || true
}

# Check if changes are significant
is_significant_change() {
    cd "$WATCH_DIR"
    
    # Check for new files (always significant)
    if git ls-files --others --exclude-standard | grep -q .; then
        return 0
    fi
    
    # Check for total line changes
    local total_changes=$(git diff --stat 2>/dev/null | tail -1 | awk '{print $4}' | tr -d 'insertion' | tr -d ',' | head -c5)
    
    if [ -z "$total_changes" ]; then
        total_changes=0
    fi
    
    if (( total_changes > MIN_LINES )); then
        return 0
    fi
    
    return 1
}

# Generate intelligent commit message
generate_commit_message() {
    cd "$WATCH_DIR"
    
    local changed_files=$(get_changed_files)
    local file_count=$(echo "$changed_files" | grep -c . || echo 0)
    local deleted_count=$(git diff --name-only --diff-filter=D 2>/dev/null | wc -l)
    local new_count=$(git ls-files --others --exclude-standard 2>/dev/null | wc -l)
    
    # Categorize changes
    local has_tests=$(echo "$changed_files" | grep -E "(test|spec)" | wc -l)
    local has_docs=$(echo "$changed_files" | grep -E "(README|\.md|docs)" | wc -l)
    local has_config=$(echo "$changed_files" | grep -E "(config|\.json|\.yaml|\.yml)" | wc -l)
    local has_src=$(echo "$changed_files" | grep -E "\.(js|ts|py|go|rb|rs|java|cpp|c)$" | wc -l)
    
    local message=""
    local details=""
    
    # Build message based on changes
    if (( new_count > 0 )); then
        message="âœ¨ feat: Add new files ($new_count new)"
        details="$new_count new file(s)"
    elif (( has_src > 0 )); then
        message="ðŸ”§ refactor: Update source code"
        details="$has_src file(s) modified"
    fi
    
    if (( has_tests > 0 )); then
        if [ -z "$message" ]; then
            message="âœ… test: Add/update tests"
        else
            message="${message} + tests"
        fi
        details="$details | tests"
    fi
    
    if (( has_docs > 0 )); then
        if [ -z "$message" ]; then
            message="ðŸ“ docs: Update documentation"
        else
            message="${message} + docs"
        fi
        details="$details | docs"
    fi
    
    if (( has_config > 0 )); then
        if [ -z "$message" ]; then
            message="âš™ï¸  config: Update configuration"
        else
            message="${message} + config"
        fi
        details="$details | config"
    fi
    
    if (( deleted_count > 0 )); then
        message="${message} (removed: $deleted_count)"
    fi
    
    # Fallback
    if [ -z "$message" ]; then
        message="ðŸ”„ chore: Auto-committed changes ($file_count file(s))"
    fi
    
    echo "$message"
}

# Stage changes
stage_changes() {
    cd "$WATCH_DIR"
    
    # Add all changes (new, modified, deleted)
    git add -A
    
    # Verify something is staged
    if ! git diff --cached --quiet 2>/dev/null; then
        return 0
    fi
    
    return 1
}

# Commit changes
commit_changes() {
    cd "$WATCH_DIR"
    
    local message="$1"
    
    git commit -m "$message" --no-verify 2>/dev/null || {
        error "Failed to commit changes"
        return 1
    }
    
    return 0
}

# Push to remote
push_to_remote() {
    cd "$WATCH_DIR"
    
    local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")
    
    if git push origin "$branch" 2>/dev/null; then
        return 0
    else
        warn "Push failed - trying with --force-with-lease"
        if git push origin "$branch" --force-with-lease 2>/dev/null; then
            return 0
        fi
        return 1
    fi
}

# Watch mode
watch_mode() {
    info "Starting auto-git-push in watch mode"
    info "Directory: $WATCH_DIR"
    info "Min changes threshold: $MIN_LINES lines"
    info "Log file: $LOG_FILE"
    info "Press Ctrl+C to stop"
    
    local last_check=$(date +%s)
    
    while true; do
        sleep 2
        
        # Debounce check
        local now=$(date +%s)
        if (( now - last_check < DEBOUNCE_SECONDS )); then
            continue
        fi
        
        cd "$WATCH_DIR"
        
        # Check if there are any changes
        if ! git diff --quiet 2>/dev/null && ! git diff --cached --quiet 2>/dev/null; then
            if ! git ls-files --others --exclude-standard 2>/dev/null | grep -q .; then
                # No changes
                continue
            fi
        fi
        
        last_check=$(date +%s)
        
        if is_significant_change; then
            info "Detected significant changes"
            
            if stage_changes; then
                local message=$(generate_commit_message)
                
                info "Generated commit message: $message"
                
                if commit_changes "$message"; then
                    success "Changes committed"
                    
                    if push_to_remote; then
                        success "Changes pushed to remote"
                    else
                        warn "Push failed - changes remain committed locally"
                    fi
                fi
            fi
        fi
    done
}

# One-time mode
once_mode() {
    info "Running one-time check"
    
    check_git_repo || return 1
    
    if ! is_significant_change; then
        info "No significant changes detected (>$MIN_LINES lines)"
        return 0
    fi
    
    info "Significant changes detected"
    
    if stage_changes; then
        local message=$(generate_commit_message)
        info "Commit message: $message"
        
        if commit_changes "$message"; then
            success "Changes committed"
            
            if push_to_remote; then
                success "Changes pushed to remote"
                return 0
            else
                error "Failed to push changes"
                return 1
            fi
        fi
    else
        warn "No changes to stage"
        return 0
    fi
}

# Main
main() {
    case "$COMMAND" in
        watch)
            watch_mode
            ;;
        once)
            once_mode
            ;;
        status)
            cd "$WATCH_DIR"
            echo "=== Git Status ==="
            git status --short
            echo ""
            echo "=== Recent Commits ==="
            git log --oneline -5
            ;;
        help|--help|-h)
            cat << 'EOF'
Auto Git Push System

Usage:
  auto-git-push [command] [directory]

Commands:
  watch          Watch directory and auto-push on changes (default)
  once           Check once and push if significant changes
  status         Show git status and recent commits
  help           Show this help message

Examples:
  auto-git-push watch .              # Watch current directory
  auto-git-push watch /path/to/repo  # Watch specific repo
  auto-git-push once .               # One-time check
  auto-git-push status .             # Show status

Configuration:
  MIN_LINES=20 auto-git-push watch   # Change line threshold

Features:
  âœ“ Detects >10 line changes
  âœ“ Detects new files
  âœ“ Intelligent commit messages
  âœ“ Debouncing (5 sec default)
  âœ“ Logging to .agp.log

Log file: .agp.log in the watched directory
EOF
            ;;
        *)
            # If first arg is a directory, treat as watch mode
            if [ -d "$COMMAND" ]; then
                WATCH_DIR="$COMMAND"
                LOG_FILE="${WATCH_DIR}/.agp.log"
                watch_mode
            else
                watch_mode
            fi
            ;;
    esac
}

main
